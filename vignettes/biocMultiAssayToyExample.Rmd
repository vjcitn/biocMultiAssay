---
title: "biocMultiAssayToyExample"
author: "Marcel Ramos, Levi Waldron"
date: "September 4, 2015"
output: html_document
---

In this example we have 4 patients, and a bit of metadata on them:
```{r}
masterpheno <- data.frame(sex=c("M", "F", "M", "F"),
                          age=38:41,
                          row.names=c("Jack", "Jill", "Bob", "Barbara"))
masterpheno
```

We have three matrix-like datasets.  First let's say expression data:

```{r, message=FALSE}
library(affy)
(arraydat <- matrix(seq(101, 108), ncol=4, dimnames=list(c("TP53", "EGFR"), c("array1", "array2", "array3", "array4"))))
arraypdat <- as(data.frame(slope53=rnorm(4), row.names=c("array1", "array2", "array3", "array4")), "AnnotatedDataFrame")
exprdat <- ExpressionSet(assayData=arraydat, phenoData=arraypdat)
exprdat
```

The following map matches masterpheno sample names to exprdata sample names.  Note that row orders aren't initially matched up.
```{r}
(exprmap <- data.frame(master=rownames(masterpheno)[c(1, 2, 4, 3)], assay=c("array1", "array2", "array3", "array4")))
```

Now methylation data.  It uses gene identifiers also, but measures a partially overlapping set of genes.  For fun, let's store this as a simple matrix. Also, it contains a replicate for one of the patients.

```{r}
(methyldat <- matrix(1:10, ncol=5, dimnames=list(c("TP53", "CXCL12"), c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"))))
```

The following map matches masterpheno sample names to methyldat sample names.

```{r}
(methylmap <- data.frame(master = c("Jack", "Jack", "Jill", "Barbara", "Bob"),
                        assay = c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5")))
```

Now we have a microRNA platform, which has no common identifiers.  It is also missing data for Jill.  Just for fun, let's use the same sample naming convention as we did for arrays.

```{r}
(microdat <- matrix(201:212, ncol=3, dimnames=list(c("miR1", "miR2", "miR3", "miR4"), c("array1", "array2", "array3"))))
```

And the following map matches masterpheno sample names to microdat sample names.
```{r}
(micromap <- data.frame(master = c("Jack", "Barbara", "Bob"),
                        assay = c("micro1", "micro2", "micro3")))
```

Let's include a GRangesList:  

```{r}
library(GenomicRanges)
rangeprep <- lapply(1:5, FUN = function(x){ 
data.frame( seqnames = rep("chr1", 5), 
	ranges = IRanges(floor(runif(5, 0, 100)), floor(runif(5, 80, 180))),
	strand = rep("+", 5), score = floor(runif(5, 1, 5)) ) })

rangelistdat <- GRangesList(lapply(rangeprep, FUN = function(x) {
	GRanges(seqnames = x$seqnames, ranges = IRanges(x$ranges.start, x$ranges.end), strand = x$strand, score = x$score) } ))

names(rangelistdat) <- c("snparray1", "snparray3", "snparray4", "snparray2", "snparray2")
# mcols is using DataFrame instead of data.frame
# mcols(rangelistdat) <- data.frame(row.names = c("Jack", "Bob", "Barbara", "Jill1", "Jill2"),  
#		tss = rep("lung", 5), ptid = c("1221", "1321", "1322", "1222", "1222")) 
```

The following data.frame matches masterpheno sample to the GRangesList: 

```{r}
(rangemap <- data.frame(master = c("Jack", "Bob", "Barbara", "Jill", "Jill"), 
						assay = c("snparray1", "snparray3", "snparray4", "snparray20", "snparray21")))
```

Create an ID map for all available experiments

```{r}
idmap <- list(exprmap, methylmap, micromap, rangemap)
names(idmap) <- c("expr", "methyl", "micro", "range")
idmap
```

ID map check for validity (all IDs present and all samples unique)

```{r}
checkMap <- function(exptchunk){

	allphenos <- ifelse(all(unique(exptchunk[,1]) %in% rownames(masterpheno)), TRUE, FALSE)
	uniqss <- ifelse(all(!duplicated(exptchunk[,2])), TRUE, FALSE)

	if(uniqss & allphenos){
		message("All ID Map checks passed!") 
		return(TRUE)
	} else if(!sampes){
		message("Samples are not unique!")
		return(FALSE)
	} else if (!phenos) {
		message("There are missing cases in the master phenodata!")
		return(FALSE)
	}
}

sapply(idmap, checkMap)
```

Allowing for the possibility of ID maps entered as dataframes, convert to conventional list: 

```{r}
library(reshape2) # reshape2 used for example only
dfmap <- melt(idmap, id.var = c("master", "assay"))

toListMap <- function(dfmap){
	newlist <- lapply(seq_along(dfmap)[-1], FUN = function(col, mydf) { 
					  cbind(mydf[1], mydf[col]) }, mydf = dfmap)
	names(newlist) <- names(dfmap)[-1]
	return(newlist)
}

toListMap(dfmap)
```

Create an (unnamed) list of experiments `objlist` for the createMA function

```{r}
objlist <- list(exprdat, methyldat, microdat, rangelistdat)
```

Create a toy multiAssayExperiment class object

```{r}
createMA <- function(masterpheno, objlist, drop=FALSE, samplemaps=NULL){
	if(!is(masterpheno, "data.frame")){
		stop("masterpheno should be a data frame of metadata for all samples")
	}
	if(!is(objlist, "list")){
		stop("objlist should be a named list of data objects")
	}

	if(!is.null(samplemaps)){

		if(any(!sapply(samplemaps, checkMap))){
			stop("The sample maps are not passing the required checks!")
		}
		if(length(objlist) != length(samplemaps)){
			stop("objlist must be the same length as samplemaps!")
		}
	} else {
		warning("No sample maps provided!")
	}

	newMAE <- new("MultiAssayExperiment", elist = objlist, masterPheno = masterpheno, sampleMap = samplemaps)
	return(newMAE)
}

MAE <- createMA(masterpheno, objlist, samplemaps = idmap)
```

Create a function that subsets depending on the input given

```{r}
subsetUnit <- function(exptChunk, chop){
	if(any(is(exptChunk, "data.frame"), is(exptChunk, "matrix"))){
		subUnit <- exptChunk[, chop]
	} else if(is(exptChunk, "GRangesList")){
		subUnit <- exptChunk[chop]
	}else if(is(exptChunk, "ExpressionSet")){
		subUnit <- exptChunk[, chop %in% sampleNames(exptChunk)] 
	}
	return(subUnit)
} 
```

Subsetting by Sample

```{r}
subsetBySample <- function(MAobject, j, drop = FALSE){

	if(isS4(MAobject) & is(MAobject, "MultiAssayExperiment")){
	   if(!is.numeric(j)){
		   stop("Row index must be an integer vector!")
		   # Enter alternate subsetting by Samples method here!
	   } else {
		   if(all(j %in% seq(nrow(MAobject@masterPheno)))){
	    masterpsub <- MAobject@masterPheno[j, ]	
			   # use subesetted rownames with ID map to subset the objlist (experiments)
		subPheno <- MAobject@masterPheno[match(rownames(masterpsub), rownames(MAobject@masterPheno)),]
		subMap <- lapply(MAobject@sampleMap, FUN = function(minimap) { na.omit(minimap[minimap[,1] %in% rownames(subPheno), ]) } ) 
chopper <- lapply(subMap, FUN = "[", 2)
browser()
subElist <- lapply(MAobject@elist, FUN = function(expt, i = seq_along(chopper), map) { 
 subsetUnit(expt, map[[i]])
 }, map = chopper ) 
		   } else { 
			   stop("Row numbers outside of masterpheno row range!")
		   }
	   }
					  }

}

subsetBySample(MAE, 1:2)
```
